/*
 *  (c) Copyright 2016-2021 Hewlett Packard Enterprise Development Company LP.
 *
 *  This software is available to you under a choice of one of two
 *  licenses. You may choose to be licensed under the terms of the 
 *  GNU Lesser General Public License Version 3, or (at your option)  
 *  later with exceptions included below, or under the terms of the  
 *  MIT license (Expat) available in COPYING file in the source tree.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the
 *  Application containing code generated by the Library and added to the
 *  Application during this compilation process under terms of your choice,
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#include "shelf_usage/participant_manager.h"

#include <errno.h>
#include <iostream>
#include <signal.h>
#include <sstream>
#include <stdexcept>
#include <stdio.h>
#include <string>
#include <unistd.h>


namespace nvmm {



/* Gets a unique id for the caller. 
   The current implementation merely returns process id of the caller.
   TODO: on The Machine, this may return SOC-id:Boot-count:PID
*/
ParticipantID ParticipantManager::get_self_id(){
    return getpid();
}


/* Checks if the given participant is alive.
   Return: true: if alive
           false: if not alive
   The API throws an error if the pid exits but does not belong to the process group or 
   can't receive a signal from the sender.
*/

bool ParticipantManager::is_alive(ParticipantID pid){
    std::ostringstream msg;
    // First check if there exists a process with this id. kill(pid, 0) accomplishes this objective.
    int ret = kill(pid, 0);
    if (ret) {
        switch(errno){
            default: {
                        perror(NULL);
                        msg << "Error in ParticipantManager::Terminate() kill(0) caller pid: " << (uint64_t)get_self_id() << " target pid: " << (uint64_t) pid;
                        throw std::runtime_error(msg.str());
                        break;
                     }

            case ESRCH: {
                       // Either someone else killed it or the passed in pid is rogue. We can't distinguish these two.
                       // We simply infer that no such participant exists
                       return false; // dead
                    }
        }
    }
    return true; // alive
}

/* Kill the process identified by pid. 
   The current implementation merely calls kill(SIGKILL). 
   The pid must be a valid id.
   The call is idempotent. If the target pid is already killed, the call acts as nop.
   The implementation can't distinguish between a rogue non-existing pid vs. a previously killed pid.
*/

void ParticipantManager::terminate(ParticipantID pid){
    std::ostringstream msg;
    // Assuming the process exits, let's attempt to kill it
    int ret = kill(pid, SIGKILL);
    if (ret) {
        switch(errno){
            default: {
                        perror(NULL);
                        msg << "Error in ParticipantManager::Terminate() kill(SIGKILL) caller pid: " << (uint64_t)get_self_id() << " target pid: " << (uint64_t) pid;
                        throw std::runtime_error(msg.str());
                        break;
                     }

            case ESRCH: { 
                       // Either someone else killed it or the passed in pid is rogue. We can't distinguish these two.
                       // We simply return in this case.
                       return;
                    }
        }
    }
}



} // end namespace nvmm
