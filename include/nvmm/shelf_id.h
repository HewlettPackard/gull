/*
 *  (c) Copyright 2016-2021 Hewlett Packard Enterprise Development Company LP.
 *
 *  This software is available to you under a choice of one of two
 *  licenses. You may choose to be licensed under the terms of the 
 *  GNU Lesser General Public License Version 3, or (at your option)  
 *  later with exceptions included below, or under the terms of the  
 *  MIT license (Expat) available in COPYING file in the source tree.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *  As an exception, the copyright holders of this Library grant you permission
 *  to (i) compile an Application with the Library, and (ii) distribute the
 *  Application containing code generated by the Library and added to the
 *  Application during this compilation process under terms of your choice,
 *  provided you also meet the terms and conditions of the Application license.
 *
 */

#ifndef _NVMM_SHELF_ID_H_
#define _NVMM_SHELF_ID_H_

#include <iostream>
#include <assert.h> // assert and static_assert
#include <functional> // std::hash

namespace nvmm{
    
// Shelf ID consists of Pool ID and Shelf Index (with in a pool)
// ShelfIdT is the internal storage type of the shelf id
// PoolIdT/ShelfIndexT is the external type of pool id/shelf index, whose size may be bigger than PoolIdTSize/ShelfIndexTSize
// ShelfIdTSize/PoolIdTSize/ShelfIndexTSize is the number of bits of ShelfIdT/PoolIdT/ShelfIndexT
template<class ShelfIdT, size_t ShelfIdTSize, class PoolIdT, size_t PoolIdTSize, class ShelfIndexT, size_t ShelfIndexTSize>
class ShelfIdClass
{
    static_assert(sizeof(ShelfIdT)*8 >= ShelfIdTSize, "Invalid ShelfIdT");
    static_assert(sizeof(PoolIdT)*8 >= PoolIdTSize, "Invalid PoolIdT");
    static_assert(sizeof(ShelfIndexT)*8 >= ShelfIndexTSize, "Invalid ShelfIndexT");
    static_assert(PoolIdTSize + ShelfIndexTSize <= ShelfIdTSize, "Invalid sizes");
    
public:
    // invalid shelf id: pool id == 0 && shelf index == 0
    static ShelfIdT const kInvalidShelfId = 0; 

    // max pool count and shelf count per pool
    static PoolIdT const kMaxPoolCount = 1UL<<14;
    static ShelfIndexT const kMaxShelfCount = 1UL<<7;
    
    // Total number of bits used for PoolId + ShelfId
    static uint8_t const kPoolIdShelfIdbits = 24;

    ShelfIdClass()
        : shelf_id_{kInvalidShelfId}
    {
    }

    ShelfIdClass(ShelfIdT shelf_id)
        : shelf_id_{shelf_id}
    {
    }
    
    ShelfIdClass(PoolIdT pool_id, ShelfIndexT shelf_idx)
        : shelf_id_{EncodeShelfId(pool_id, shelf_idx)}
    {
        assert(pool_id<kMaxPoolCount && shelf_idx<kMaxShelfCount);        
    }

    ~ShelfIdClass()
    {
    }


    operator uint64_t() const
    {
	return (uint64_t)shelf_id_;
    }

    inline bool IsValid() const
    {
        return
            (GetPoolId()<kMaxPoolCount) &&
            (GetShelfIndex()<kMaxShelfCount) && (shelf_id_ != kInvalidShelfId);
    }
    
    inline PoolIdT GetPoolId() const
    {
        return DecodePoolId(shelf_id_);
    }

    inline ShelfIndexT GetShelfIndex() const
    {
        return DecodeShelfIndex(shelf_id_);
    }

    inline ShelfIdT GetShelfId() const
    {
        return shelf_id_;
    }

    // operators
    friend std::ostream& operator<<(std::ostream& os, const ShelfIdClass& shelf_id)
    {
        os << "[" << ((uint64_t)shelf_id.GetPoolId()) << "_" << ((uint64_t)shelf_id.GetShelfIndex()) << "]";
        return os;
    }

    friend bool operator==(const ShelfIdClass &left, const ShelfIdClass &right)
    {
        return left.shelf_id_ == right.shelf_id_;
    }   

    friend bool operator!=(const ShelfIdClass &left, const ShelfIdClass &right)
    {
        return !(left == right);
    }   

    // hash and equal function for std::unordered_map<ShelfID, ...>
    struct Hash {
        unsigned long operator()(const ShelfIdClass& key) const
        {
            return std::hash<ShelfIdT>()(key.GetShelfId());
        }
    };

    struct Equal {
        bool operator()(const ShelfIdClass& lhs, const ShelfIdClass& rhs) const {
            return lhs.GetShelfId() == rhs.GetShelfId();
        }
    };
    
    
private:
    inline ShelfIdT EncodeShelfId(PoolIdT pool_id, ShelfIndexT shelf_idx) const
    {
        return (ShelfIdT)((((ShelfIdT)pool_id) << (ShelfIndexTSize)) + shelf_idx);
    }

    inline PoolIdT DecodePoolId(ShelfIdT shelf_id) const
    {
        return (PoolIdT)(((ShelfIdT)shelf_id) >> (ShelfIndexTSize));
    }

    inline ShelfIndexT DecodeShelfIndex(ShelfIdT shelf_id) const
    {
        return (ShelfIndexT)(((((ShelfIdT)1) << (ShelfIndexTSize)) - 1) & shelf_id);
    }
    
    ShelfIdT shelf_id_;
};

    
// internal type of ShelfId
using ShelfIdStorageType = uint32_t;

// PoolId
using PoolId = uint16_t;

// ShelfIndex
using ShelfIndex = uint8_t;

// ShelfId: 24-bit shelf id with 16-bit as pool id and 8-bit as shelf index
using ShelfId = ShelfIdClass<ShelfIdStorageType, 24, PoolId, 16, ShelfIndex, 8>;
    
} // namespace nvmm

#endif
